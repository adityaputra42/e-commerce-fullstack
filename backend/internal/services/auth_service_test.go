package services_test

import (
	"e-commerce/backend/internal/config"
	"e-commerce/backend/internal/mocks"
	"e-commerce/backend/internal/models"
	"e-commerce/backend/internal/services"
	"e-commerce/backend/internal/testhelper"
	"e-commerce/backend/internal/utils"
	"testing"
	"time"

	"go.uber.org/mock/gomock"
	"gorm.io/gorm"
)

func TestAuthService_SignUp(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockUserRepo := mocks.NewMockUserRepository(ctrl)
	mockRoleRepo := mocks.NewMockRoleRepository(ctrl)
	
	cfg := &config.Config{JWT: config.JWTConfig{Secret: "test", AccessTokenExpiry: time.Hour, RefreshSecret: "refresh", RefreshTokenExpiry: time.Hour}}
	jwtService := utils.NewJWTService(cfg)
	
	service := services.NewAuthService(jwtService, mockUserRepo, nil, mockRoleRepo, nil)

	t.Run("Success", func(t *testing.T) {
		req := models.RegisterRequest{
			Email:    "new@example.com",
			Password: "password",
			Username: "newuser",
			FirstName: "New",
			LastName: "User",
		}
		
		role := models.Role{ID: 1, Name: "User"}
		
		mockUserRepo.EXPECT().FindByEmail(req.Email).Return(models.User{}, gorm.ErrRecordNotFound)
		mockRoleRepo.EXPECT().FindByName("User").Return(role, nil)
		
		mockUserRepo.EXPECT().
			Create(gomock.Any()).
			DoAndReturn(func(u models.User) (models.User, error) {
				u.ID = 10
				return u, nil
			})
			
		resp, err := service.SignUp(req)
		
		if err != nil {
			t.Errorf("Unexpected error: %v", err)
		}
		if resp != nil && resp.User.Email != req.Email {
			t.Errorf("Expected email %s, got %s", req.Email, resp.User.Email)
		}
	})
	
	t.Run("EmailAlreadyExists", func(t *testing.T) {
		req := models.RegisterRequest{ Email: "exists@example.com", Password: "pwd" }
		mockUserRepo.EXPECT().FindByEmail(req.Email).Return(models.User{ID: 1}, nil)
		
		_, err := service.SignUp(req)
		if err == nil {
			t.Error("Expected error for existing email")
		}
	})
}

func TestAuthService_SignIn(t *testing.T) {
	// Initialize TestDB with Clean state & Migrations using SetupTestSuite
	testDB := testhelper.SetupTestSuite(t)

	tx := testhelper.BeginTestTransaction(t, testDB)
	defer testhelper.RollbackTestTransaction(tx)
	
	dbWrapper := testhelper.SetTestDB(tx)
	defer dbWrapper.Restore()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockUserRepo := mocks.NewMockUserRepository(ctrl)
	mockActivityRepo := mocks.NewMockActivityLogRepository(ctrl)

	cfg := &config.Config{JWT: config.JWTConfig{Secret: "test", AccessTokenExpiry: time.Hour, RefreshSecret: "refresh", RefreshTokenExpiry: time.Hour}}
	jwtService := utils.NewJWTService(cfg)

	service := services.NewAuthService(jwtService, mockUserRepo, mockActivityRepo, nil, nil)

	t.Run("Success", func(t *testing.T) {
		// Insert dependent Role data into the DB to satisfy FK constraints during Save
		role := models.Role{Name: "User"}
		if err := testDB.Create(&role).Error; err != nil {
			t.Fatalf("Failed to create test role: %v", err)
		}

		req := models.LoginRequest{
			Email:    "login@example.com",
			Password: "password",
		}

		hashedPwd, _ := utils.HashPassword("password")
		user := models.User{
			ID:           1,
			Email:        "login@example.com",
			PasswordHash: hashedPwd,
			IsActive:     true,
			RoleID:       role.ID, // Use the real ID generated by DB
			Role: 		  role,
		}

		// Mock FindByEmail to return our prepared user object
		mockUserRepo.EXPECT().FindByEmail(req.Email).Return(user, nil)
		
		// Expect ActivityLog creation
		mockActivityRepo.EXPECT().Create(gomock.Any(), gomock.Any()).Return(models.ActivityLog{}, nil)

		resp, err := service.SignIn(req, "127.0.0.1", "TestAgent")
		
		if err != nil {
			t.Errorf("Unexpected error: %v", err)
		}
		if resp != nil && resp.AccessToken == "" {
			t.Errorf("Expected access token")
		}
	})
}
